"""
ComfyUIËá™ÂÆö‰πâËäÇÁÇπÔºöÊñáÊú¨Ë¶ÜÁõñËßÜÈ¢ëËäÇÁÇπ
‰∏∫ËßÜÈ¢ëÊ∑ªÂä†Ëá™ÂÆö‰πâÊñáÊú¨Ë¶ÜÁõñÂäüËÉΩ
"""

import os
import sys
import logging
import tempfile
import time
from typing import Dict, Any, Tuple, Optional
from datetime import datetime

# Ê∑ªÂä†Áà∂ÁõÆÂΩïÂà∞PythonË∑ØÂæÑ‰ª•ÊîØÊåÅÂØºÂÖ•
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)

try:
    from ..services.text_overlay_service import TextOverlayService, TextOverlayStyle, TextAlignment, TextEffectType
    from ..core.subtitle_style import PresetStyles, SubtitleStyle, SubtitlePosition, FontWeight
except ImportError:
    from services.text_overlay_service import TextOverlayService, TextOverlayStyle, TextAlignment, TextEffectType
    from core.subtitle_style import PresetStyles, SubtitleStyle, SubtitlePosition, FontWeight


class ProgressLogger:
    """ËøõÂ∫¶Êó•ÂøóËÆ∞ÂΩïÂô®"""
    
    def __init__(self, task_name: str):
        self.task_name = task_name
        self.start_time = time.time()
        self.last_update = self.start_time
        
    def log_progress(self, step: str, detail: str = "", progress_percent: float = None):
        """ËÆ∞ÂΩïËøõÂ∫¶‰ø°ÊÅØ"""
        current_time = time.time()
        elapsed = current_time - self.start_time
        
        # Ê†ºÂºèÂåñËæìÂá∫
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        if progress_percent is not None:
            progress_bar = self._create_progress_bar(progress_percent)
            print(f"\033[32m[{timestamp}]\033[0m \033[36m{self.task_name}\033[0m - {step}")
            print(f"         {progress_bar} {progress_percent:.1f}%")
            if detail:
                print(f"         üìù {detail}")
        else:
            print(f"\033[32m[{timestamp}]\033[0m \033[36m{self.task_name}\033[0m - üîÑ {step}")
            if detail:
                print(f"         üìù {detail}")
        
        print(f"         ‚è±Ô∏è  Â∑≤Áî®Êó∂: {elapsed:.1f}Áßí")
        print()  # Á©∫Ë°åÂàÜÈöî
        
    def log_success(self, message: str):
        """ËÆ∞ÂΩïÊàêÂäü‰ø°ÊÅØ"""
        elapsed = time.time() - self.start_time
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"\033[32m[{timestamp}]\033[0m \033[36m{self.task_name}\033[0m - ‚úÖ {message}")
        print(f"         ‚è±Ô∏è  ÊÄªÁî®Êó∂: {elapsed:.1f}Áßí")
        print()
        
    def log_error(self, message: str):
        """ËÆ∞ÂΩïÈîôËØØ‰ø°ÊÅØ"""
        elapsed = time.time() - self.start_time
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"\033[31m[{timestamp}]\033[0m \033[36m{self.task_name}\033[0m - ‚ùå {message}")
        print(f"         ‚è±Ô∏è  Áî®Êó∂: {elapsed:.1f}Áßí")
        print()
        
    def _create_progress_bar(self, percent: float, width: int = 30) -> str:
        """ÂàõÂª∫ËøõÂ∫¶Êù°"""
        filled = int(width * percent / 100)
        bar = "‚ñà" * filled + "‚ñë" * (width - filled)
        return f"[{bar}]"


class TextOverlayVideoNode:
    """ComfyUIÊñáÊú¨Ë¶ÜÁõñËßÜÈ¢ëËäÇÁÇπ"""
    
    def __init__(self):
        try:
            self.service = TextOverlayService()
            print("‚úÖ TextOverlayService ÂàùÂßãÂåñÊàêÂäü")
            
            # ÂàùÂßãÂåñÂ≠ó‰ΩìÂàóË°®
            self._available_fonts = None
            self._load_available_fonts()
            
        except Exception as e:
            print(f"‚ùå TextOverlayService ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            import traceback
            print(traceback.format_exc())
            raise
        self.setup_logging()
    
    def _load_available_fonts(self):
        """Âä†ËΩΩÁ≥ªÁªüÂèØÁî®Â≠ó‰Ωì"""
        try:
            fonts = self.service.get_available_fonts()
            if fonts and len(fonts) > 0:
                self._available_fonts = fonts
                print(f"‚úÖ ÊàêÂäüÊ£ÄÊµãÂà∞ {len(fonts)} ÁßçÂèØÁî®Â≠ó‰Ωì")
                # ÊòæÁ§∫Ââç10‰∏™Â≠ó‰Ωì‰Ωú‰∏∫Á§∫‰æã
                print("üìù ÂèØÁî®Â≠ó‰ΩìÁ§∫‰æã:", fonts[:10])
            else:
                print("‚ö†Ô∏è Êú™Ê£ÄÊµãÂà∞Á≥ªÁªüÂ≠ó‰ΩìÔºå‰ΩøÁî®ÈªòËÆ§Â≠ó‰ΩìÂàóË°®")
                self._available_fonts = self._get_fallback_fonts()
        except Exception as e:
            print(f"‚ö†Ô∏è Ê£ÄÊµãÁ≥ªÁªüÂ≠ó‰ΩìÊó∂Âá∫Èîô: {e}")
            self._available_fonts = self._get_fallback_fonts()
    
    def _get_fallback_fonts(self):
        """Ëé∑ÂèñÂ§áÁî®Â≠ó‰ΩìÂàóË°®"""
        return [
            "DejaVu Sans",
            "DejaVu Serif", 
            "DejaVu Sans Mono",
            "Liberation Sans",
            "Liberation Serif",
            "Liberation Mono",
            "WenQuanYi Zen Hei",
            "Lato",
            "Noto Sans",
            "Arial",
            "Times New Roman",
            "Courier New"
        ]
    
    def setup_logging(self):
        """ËÆæÁΩÆÊó•ÂøóÈÖçÁΩÆ"""
        # ÈÖçÁΩÆÁªàÁ´ØÊó•ÂøóËæìÂá∫
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            force=True
        )
        self.logger = logging.getLogger(f"TextOverlay_{id(self)}")
    
    def get_color_rgb(self, color_name: str) -> tuple:
        """Â∞ÜÈ¢úËâ≤ÂêçÁß∞ËΩ¨Êç¢‰∏∫RGBÂÄº"""
        color_map = {
            # ‰∏≠ÊñáÈ¢úËâ≤ÂêçÁß∞Êò†Â∞Ñ
            "ÈªëËâ≤": (0, 0, 0),
            "ÁôΩËâ≤": (255, 255, 255),
            "Á∫¢Ëâ≤": (255, 0, 0),
            "ÁªøËâ≤": (0, 255, 0),
            "ËìùËâ≤": (0, 0, 255),
            "ÈªÑËâ≤": (255, 255, 0),
            "ÈùíËâ≤": (0, 255, 255),
            "Ê¥ãÁ∫¢": (255, 0, 255),
            "Ê©ôËâ≤": (255, 165, 0),
            "Á¥´Ëâ≤": (128, 0, 128),
            "ÁÅ∞Ëâ≤": (128, 128, 128),
            "Ê∑±ÁÅ∞": (64, 64, 64),
            "ÊµÖÁÅ∞": (192, 192, 192),
            "ÈÄèÊòé": (0, 0, 0),  # ÈÄèÊòéËÉåÊôØÁî®ÈªëËâ≤Ôºå‰ΩÜ‰ºöËÆæÁΩÆ‰∏∫ÂÆåÂÖ®ÈÄèÊòé
            # ÂÖºÂÆπËã±ÊñáÂêçÁß∞ÔºàÂêë‰∏ãÂÖºÂÆπÔºâ
            "black": (0, 0, 0),
            "white": (255, 255, 255),
            "red": (255, 0, 0),
            "green": (0, 255, 0),
            "blue": (0, 0, 255),
            "yellow": (255, 255, 0),
            "cyan": (0, 255, 255),
            "magenta": (255, 0, 255),
            "orange": (255, 165, 0),
            "purple": (128, 0, 128),
            "gray": (128, 128, 128),
            "darkgray": (64, 64, 64),
            "lightgray": (192, 192, 192),
            "transparent": (0, 0, 0)
        }
        return color_map.get(color_name, (0, 0, 0))
    
    def get_position_preset(self, position_name: str) -> str:
        """Â∞Ü‰∏≠Êñá‰ΩçÁΩÆÂêçÁß∞ËΩ¨Êç¢‰∏∫Ëã±ÊñáÈ¢ÑËÆæÂêçÁß∞"""
        position_map = {
            "Â∫ïÈÉ®Â±Ö‰∏≠": "bottom",
            "Â∫ïÈÉ®ÂÅè‰∏ã": "bottom_low", 
            "Â∫ïÈÉ®ÂÅè‰∏ä": "bottom_high",
            "Â±èÂπï‰∏≠Â§Æ": "center",
            "‰∏≠Â§ÆÂÅè‰∏ã": "center_low",
            "‰∏≠Â§ÆÂÅè‰∏ä": "center_high",
            "È°∂ÈÉ®Â±Ö‰∏≠": "top",
            "È°∂ÈÉ®ÂÅè‰∏ã": "top_low",
            "È°∂ÈÉ®ÂÅè‰∏ä": "top_high",
            # ÂÖºÂÆπËã±ÊñáÂêçÁß∞ÔºàÂêë‰∏ãÂÖºÂÆπÔºâ
            "bottom": "bottom",
            "bottom_low": "bottom_low",
            "bottom_high": "bottom_high",
            "center": "center",
            "center_low": "center_low",
            "center_high": "center_high",
            "top": "top",
            "top_low": "top_low",
            "top_high": "top_high"
        }
        return position_map.get(position_name, "bottom")
    
    def get_text_alignment(self, alignment_name: str) -> str:
        """Â∞Ü‰∏≠ÊñáÂØπÈΩêÊñπÂºèËΩ¨Êç¢‰∏∫Ëã±Êñá"""
        alignment_map = {
            "Â±Ö‰∏≠": "center",
            "Â∑¶ÂØπÈΩê": "left",
            "Âè≥ÂØπÈΩê": "right",
            # ÂÖºÂÆπËã±ÊñáÂêçÁß∞ÔºàÂêë‰∏ãÂÖºÂÆπÔºâ
            "center": "center",
            "left": "left",
            "right": "right"
        }
        return alignment_map.get(alignment_name, "center")
    
    def get_tiktok_preset_style(self, preset_name: str) -> Optional[SubtitleStyle]:
        """Ëé∑ÂèñTikTokÈ¢ÑËÆæÊ†∑Âºè"""
        preset_map = {
            "üî• TikTokÁªèÂÖ∏": PresetStyles.tiktok_classic,
            "‚ú® TikTokÈúìËôπ": PresetStyles.tiktok_neon,
            "üí™ TikTokÁ≤ó‰Ωì": PresetStyles.tiktok_bold,
            "üåà TikTokÂΩ©Ëâ≤": PresetStyles.tiktok_colorful,
            "üåü TikTokÁÆÄÁ∫¶": PresetStyles.tiktok_minimal,
            "üìñ TikTokÊïÖ‰∫ã": PresetStyles.tiktok_story,
            "üíÉ TikTokËàûËπà": PresetStyles.tiktok_dance,
            "üíé TikTokÂ•¢Âçé": PresetStyles.tiktok_luxury
        }
        
        if preset_name in preset_map:
            return preset_map[preset_name]()
        return None
    
    def convert_subtitle_style_to_overlay_style(self, subtitle_style: SubtitleStyle) -> TextOverlayStyle:
        """Â∞ÜSubtitleStyleËΩ¨Êç¢‰∏∫TextOverlayStyle"""
        overlay_style = TextOverlayStyle()
        
        # ‰ΩçÁΩÆÊò†Â∞Ñ
        position_map = {
            SubtitlePosition.BOTTOM_CENTER: "bottom",
            SubtitlePosition.BOTTOM_LEFT: "bottom",
            SubtitlePosition.BOTTOM_RIGHT: "bottom", 
            SubtitlePosition.TOP_CENTER: "top",
            SubtitlePosition.TOP_LEFT: "top",
            SubtitlePosition.TOP_RIGHT: "top",
            SubtitlePosition.CENTER: "center",
            SubtitlePosition.CUSTOM: "center"
        }
        
        overlay_style.position_preset = position_map.get(subtitle_style.position, "bottom")
        overlay_style.margin_x = subtitle_style.margin_x
        
        # Â≠ó‰ΩìËÆæÁΩÆ
        overlay_style.font_family = subtitle_style.font_family
        overlay_style.font_size = subtitle_style.font_size
        overlay_style.font_color = subtitle_style.font_color
        overlay_style.font_bold = (subtitle_style.font_weight == FontWeight.BOLD)
        
        # ËÉåÊôØËÆæÁΩÆ
        overlay_style.background_enabled = subtitle_style.background_enabled
        if len(subtitle_style.background_color) == 4:  # RGBA
            overlay_style.background_color = subtitle_style.background_color[:3]
            overlay_style.background_opacity = subtitle_style.background_color[3] / 255.0
        else:  # RGB
            overlay_style.background_color = subtitle_style.background_color
            overlay_style.background_opacity = 0.8
        overlay_style.background_padding = subtitle_style.background_padding
        
        # Èò¥ÂΩ±ËÆæÁΩÆ
        overlay_style.enable_shadow = subtitle_style.shadow_enabled
        overlay_style.shadow_color = subtitle_style.shadow_color
        overlay_style.shadow_offset_x = subtitle_style.shadow_offset_x
        overlay_style.shadow_offset_y = subtitle_style.shadow_offset_y
        
        # ËæπÊ°ÜËÆæÁΩÆ
        overlay_style.enable_border = (subtitle_style.outline_width > 0)
        overlay_style.border_color = subtitle_style.outline_color
        overlay_style.border_width = subtitle_style.outline_width
        
        # ÊñáÊú¨ÊéíÁâà
        overlay_style.line_spacing = int(subtitle_style.line_spacing * 5)  # ËΩ¨Êç¢‰∏∫ÂÉèÁ¥†ÂÄº
        
        return overlay_style
    
    def apply_visual_effect(self, style: TextOverlayStyle, effect_name: str) -> None:
        """Â∫îÁî®ËßÜËßâÊïàÊûúÂà∞Ê†∑Âºè"""
        if effect_name == "üåü ÂèëÂÖâÊïàÊûú":
            style.glow_enabled = True
            style.glow_color = (255, 255, 255)
            style.glow_intensity = 8
            style.glow_spread = 2
            
        elif effect_name == "üéØ ÂèåÈáçÊèèËæπ":
            style.double_outline_enabled = True
            style.outline_inner_width = 2
            style.outline_inner_color = (255, 255, 255)
            style.outline_outer_width = 5
            style.outline_outer_color = (0, 0, 0)
            
        elif effect_name == "üí´ ÈúìËôπÊïàÊûú":
            style.neon_enabled = True
            style.neon_base_color = (255, 20, 147)  # ÈúìËôπÁ≤â
            style.neon_glow_layers = 3
            style.neon_intensity = 10
            
        elif effect_name == "üì¶ 3DÁ´ã‰ΩìÈò¥ÂΩ±":
            style.shadow_3d_enabled = True
            style.shadow_3d_layers = 5
            style.shadow_3d_depth = 3
            style.shadow_3d_angle = 225
            
        elif effect_name == "‚ö° ÊïÖÈöúÊïàÊûú":
            style.glitch_enabled = True
            style.glitch_displacement = 3
            style.glitch_color_shift = True
    
    def wrap_text(self, text: str, max_chars_per_line: int) -> str:
        """
        ÊñáÊú¨Ëá™Âä®Êç¢Ë°åÂ§ÑÁêÜ
        
        Args:
            text: ÂéüÂßãÊñáÊú¨
            max_chars_per_line: ÊØèË°åÊúÄÂ§ßÂ≠óÁ¨¶Êï∞
            
        Returns:
            Â§ÑÁêÜÂêéÁöÑÊñáÊú¨ÔºàÂåÖÂê´Êç¢Ë°åÁ¨¶Ôºâ
        """
        if not text:
            return text
            
        # ÂÖàÂ§ÑÁêÜÂ∑≤ÊúâÁöÑÊç¢Ë°åÁ¨¶
        lines = text.split('\n')
        wrapped_lines = []
        
        for line in lines:
            if len(line) <= max_chars_per_line:
                wrapped_lines.append(line)
                continue
                
            # ÂØπÈïøË°åËøõË°åÂ§ÑÁêÜ
            current_line = ""
            words = line.split(' ')
            
            for word in words:
                # Â¶ÇÊûúÂçï‰∏™ÂçïËØçÂ∞±Ë∂ÖËøá‰∫ÜÊúÄÂ§ßÈïøÂ∫¶ÔºåÂº∫Âà∂Êñ≠ÂºÄ
                if len(word) > max_chars_per_line:
                    # ÂÖàÊ∑ªÂä†ÂΩìÂâçË°åÔºàÂ¶ÇÊûúÊúâÂÜÖÂÆπÔºâ
                    if current_line:
                        wrapped_lines.append(current_line.strip())
                        current_line = ""
                    
                    # Âº∫Âà∂Êñ≠ÂºÄÈïøÂçïËØç
                    for i in range(0, len(word), max_chars_per_line):
                        chunk = word[i:i + max_chars_per_line]
                        wrapped_lines.append(chunk)
                    continue
                
                # Ê£ÄÊü•Ê∑ªÂä†Ëøô‰∏™ÂçïËØçÂêéÊòØÂê¶‰ºöË∂ÖËøáÈôêÂà∂
                test_line = current_line + (" " if current_line else "") + word
                
                if len(test_line) <= max_chars_per_line:
                    current_line = test_line
                else:
                    # ÂΩìÂâçË°åÂ∑≤Êª°ÔºåÂºÄÂßãÊñ∞Ë°å
                    if current_line:
                        wrapped_lines.append(current_line.strip())
                    current_line = word
            
            # Ê∑ªÂä†ÊúÄÂêé‰∏ÄË°å
            if current_line:
                wrapped_lines.append(current_line.strip())
        
        return '\n'.join(wrapped_lines)
    
    @classmethod
    def _get_font_options(cls) -> list:
        """Ëé∑ÂèñÂ∏¶ËØ≠ÁßçÊ†áÊ≥®ÁöÑÂ≠ó‰ΩìÈÄâÈ°πÂàóË°®"""
        try:
            # ÂàõÂª∫‰∏¥Êó∂ÊúçÂä°ÂÆû‰æãÊù•Ëé∑ÂèñÂ≠ó‰Ωì
            service = TextOverlayService()
            labeled_fonts = service.font_manager.get_fonts_with_language_labels()
            if labeled_fonts and len(labeled_fonts) > 0:
                return labeled_fonts
        except Exception as e:
            print(f"Ëé∑ÂèñÂ≠ó‰ΩìÂàóË°®Êó∂Âá∫Èîô: {e}")
        
        # ËøîÂõûÂ§áÁî®Â∏¶Ê†áÁ≠æÂ≠ó‰ΩìÂàóË°®
        return [
            "[EN] DejaVu Sans",
            "[EN] DejaVu Serif", 
            "[EN] DejaVu Sans Mono",
            "[EN] Liberation Sans",
            "[EN] Liberation Serif",
            "[EN] Liberation Mono",
            "[CN] WenQuanYi Zen Hei",
            "[EN] Lato",
            "[EN] Noto Sans"
        ]
    
    @classmethod
    def _get_default_font(cls) -> str:
        """Ëé∑ÂèñÈªòËÆ§Â≠ó‰Ωì"""
        fonts = cls._get_font_options()
        if fonts:
            # ‰ºòÂÖàÈÄâÊã©Â∏∏ËßÅÁöÑËã±ÊñáÊó†Ë°¨Á∫øÂ≠ó‰ΩìÔºàÂ∏¶Ê†áÁ≠æÁâàÊú¨Ôºâ
            preferred_patterns = ["[EN] DejaVu Sans", "[EN] Liberation Sans", "[EN] Arial", "[EN] Lato"]
            for pattern in preferred_patterns:
                for font in fonts:
                    if pattern in font:
                        return font
            return fonts[0]  # ËøîÂõûÁ¨¨‰∏Ä‰∏™ÂèØÁî®Â≠ó‰Ωì
        return "[EN] DejaVu Sans"  # ÊúÄÂêéÁöÑÂ§áÁî®
    
    def get_text_stats(self, text: str) -> dict:
        """
        Ëé∑ÂèñÊñáÊú¨ÁªüËÆ°‰ø°ÊÅØ
        
        Args:
            text: ÊñáÊú¨ÂÜÖÂÆπ
            
        Returns:
            ÊñáÊú¨ÁªüËÆ°‰ø°ÊÅØÂ≠óÂÖ∏
        """
        lines = text.split('\n')
        return {
            'total_chars': len(text),
            'total_lines': len(lines),
            'max_line_length': max(len(line) for line in lines) if lines else 0,
            'avg_line_length': sum(len(line) for line in lines) / len(lines) if lines else 0
        }
        
    @classmethod
    def INPUT_TYPES(cls):
        """ÂÆö‰πâËäÇÁÇπËæìÂÖ•Á±ªÂûã"""
        return {
            "required": {
                "images": ("IMAGE", {
                    "tooltip": "ËæìÂÖ•ÂõæÂÉèÂ∫èÂàóÔºàÊù•Ëá™ËßÜÈ¢ëÊàñÂõæÂÉèÂ§ÑÁêÜËäÇÁÇπÔºâ"
                }),
                "ÊñáÊú¨ÂÜÖÂÆπ": ("STRING", {
                    "default": "Âú®ËøôÈáåËæìÂÖ•ÊñáÊú¨ÂÜÖÂÆπ",
                    "multiline": True,
                    "placeholder": "Ë¶ÅÊòæÁ§∫Âú®ËßÜÈ¢ë‰∏äÁöÑÊñáÊú¨"
                }),
                "TikTokÈ¢ÑËÆæ": ([
                    "‰∏ç‰ΩøÁî®È¢ÑËÆæ",
                    "üî• TikTokÁªèÂÖ∏",
                    "‚ú® TikTokÈúìËôπ", 
                    "üí™ TikTokÁ≤ó‰Ωì",
                    "üåà TikTokÂΩ©Ëâ≤",
                    "üåü TikTokÁÆÄÁ∫¶",
                    "üìñ TikTokÊïÖ‰∫ã",
                    "üíÉ TikTokËàûËπà",
                    "üíé TikTokÂ•¢Âçé"
                ], {
                    "default": "‰∏ç‰ΩøÁî®È¢ÑËÆæ",
                    "tooltip": "ÈÄâÊã©‰∏ìÈó®‰∏∫TikTok‰ºòÂåñÁöÑÈ¢ÑËÆæÊ†∑ÂºèÔºåÂ∞ÜËá™Âä®Ë¶ÜÁõñÂÖ∂‰ªñÊ†∑ÂºèËÆæÁΩÆ"
                }),
                "ÊñáÊú¨‰ΩçÁΩÆ": ([
                    "Â∫ïÈÉ®Â±Ö‰∏≠",          # bottom
                    "Â∫ïÈÉ®ÂÅè‰∏ã",          # bottom_low
                    "Â∫ïÈÉ®ÂÅè‰∏ä",          # bottom_high
                    "Â±èÂπï‰∏≠Â§Æ",          # center
                    "‰∏≠Â§ÆÂÅè‰∏ã",          # center_low
                    "‰∏≠Â§ÆÂÅè‰∏ä",          # center_high
                    "È°∂ÈÉ®Â±Ö‰∏≠",          # top
                    "È°∂ÈÉ®ÂÅè‰∏ã",          # top_low
                    "È°∂ÈÉ®ÂÅè‰∏ä"           # top_high
                ], {
                    "default": "Â∫ïÈÉ®Â±Ö‰∏≠",
                    "tooltip": "ÊñáÊú¨Âú®ËßÜÈ¢ë‰∏≠ÁöÑÂûÇÁõ¥‰ΩçÁΩÆÔºàÊ∞¥Âπ≥ÊñπÂêëÂßãÁªàÂ±Ö‰∏≠Ôºâ"
                }),
                "Â≠ó‰ΩìÁ±ªÂûã": (cls._get_font_options(), {
                    "default": cls._get_default_font(),
                    "tooltip": "Â≠ó‰ΩìÁ±ªÂûãÈÄâÊã©ÔºàÂü∫‰∫éÁ≥ªÁªüÂÆûÈôÖÂèØÁî®Â≠ó‰ΩìÔºâ"
                }),
                "Â≠ó‰ΩìÂ§ßÂ∞è": ("INT", {
                    "default": 24,
                    "min": 12,
                    "max": 72,
                    "step": 1,
                    "tooltip": "Â≠ó‰ΩìÂ§ßÂ∞èÔºàÂÉèÁ¥†Ôºâ"
                }),
                "Â≠ó‰ΩìÈ¢úËâ≤": ([
                    "ÈªëËâ≤",          # black
                    "ÁôΩËâ≤",          # white
                    "Á∫¢Ëâ≤",          # red
                    "ÁªøËâ≤",          # green
                    "ËìùËâ≤",          # blue
                    "ÈªÑËâ≤",          # yellow
                    "ÈùíËâ≤",          # cyan
                    "Ê¥ãÁ∫¢",          # magenta
                    "Ê©ôËâ≤",          # orange
                    "Á¥´Ëâ≤",          # purple
                    "ÁÅ∞Ëâ≤",          # gray
                    "Ê∑±ÁÅ∞"           # darkgray
                ], {
                    "default": "ÈªëËâ≤",
                    "tooltip": "Â≠ó‰ΩìÈ¢úËâ≤È¢ÑËÆæ"
                }),
                "ËÉåÊôØÈ¢úËâ≤": ([
                    "ÁôΩËâ≤",          # white
                    "ÈªëËâ≤",          # black
                    "ÈÄèÊòé",          # transparent
                    "Á∫¢Ëâ≤",          # red
                    "ÁªøËâ≤",          # green
                    "ËìùËâ≤",          # blue
                    "ÈªÑËâ≤",          # yellow
                    "ÈùíËâ≤",          # cyan
                    "Ê¥ãÁ∫¢",          # magenta
                    "Ê©ôËâ≤",          # orange
                    "Á¥´Ëâ≤",          # purple
                    "ÁÅ∞Ëâ≤",          # gray
                    "ÊµÖÁÅ∞"           # lightgray
                ], {
                    "default": "ÁôΩËâ≤",
                    "tooltip": "ËÉåÊôØÈ¢úËâ≤È¢ÑËÆæ"
                }),
                "ËÉåÊôØÈÄèÊòéÂ∫¶": ("FLOAT", {
                    "default": 0.8,
                    "min": 0.0,
                    "max": 1.0,
                    "step": 0.1,
                    "tooltip": "ËÉåÊôØÈÄèÊòéÂ∫¶Ôºà0=ÂÆåÂÖ®ÈÄèÊòéÔºå1=ÂÆåÂÖ®‰∏çÈÄèÊòéÔºâ"
                }),
                "ÊØèË°åÂ≠óÁ¨¶Êï∞": ("INT", {
                    "default": 30,
                    "min": 10,
                    "max": 100,
                    "step": 1,
                    "tooltip": "ÊØèË°åÊúÄÂ§ßÂ≠óÁ¨¶Êï∞ÔºàË∂ÖËøáËá™Âä®Êç¢Ë°åÔºâ"
                })
            },
            "optional": {
                "ÂêØÁî®ËÉåÊôØ": ("BOOLEAN", {
                    "default": True,
                    "tooltip": "ÊòØÂê¶ÂêØÁî®ÊñáÂ≠óËÉåÊôØ"
                }),
                "Á≤ó‰ΩìÂ≠ó": ("BOOLEAN", {
                    "default": False,
                    "tooltip": "ÊòØÂê¶‰ΩøÁî®Á≤ó‰ΩìÂ≠ó"
                }),
                "ÊñáÊú¨ÂØπÈΩê": ([
                    "Â±Ö‰∏≠",        # center
                    "Â∑¶ÂØπÈΩê",      # left
                    "Âè≥ÂØπÈΩê"       # right
                ], {
                    "default": "Â±Ö‰∏≠",
                    "tooltip": "ÊñáÊú¨ÂØπÈΩêÊñπÂºè"
                }),
                "ÂêØÁî®Èò¥ÂΩ±": ("BOOLEAN", {
                    "default": False,
                    "tooltip": "ÊòØÂê¶ÂêØÁî®ÊñáÂ≠óÈò¥ÂΩ±"
                }),
                "ÂêØÁî®ËæπÊ°Ü": ("BOOLEAN", {
                    "default": False,
                    "tooltip": "ÊòØÂê¶ÂêØÁî®ÊñáÂ≠óËæπÊ°Ü"
                }),
                "Ê∞¥Âπ≥ËæπË∑ù": ("INT", {
                    "default": 50,
                    "min": 0,
                    "max": 200,
                    "step": 5,
                    "tooltip": "Ê∞¥Âπ≥ËæπË∑ùÔºàÂÉèÁ¥†Ôºâ"
                }),
                "Ë°åÈó¥Ë∑ù": ("INT", {
                    "default": 4,
                    "min": 0,
                    "max": 20,
                    "step": 1,
                    "tooltip": "Â§öË°åÊñáÊú¨ÁöÑË°åÈó¥Ë∑ùÔºàÂÉèÁ¥†Ôºâ"
                }),
                "ËßÜËßâÊïàÊûú": ([
                    "Êó†ÊïàÊûú",
                    "üåü ÂèëÂÖâÊïàÊûú",
                    "üéØ ÂèåÈáçÊèèËæπ",
                    "üí´ ÈúìËôπÊïàÊûú",
                    "üì¶ 3DÁ´ã‰ΩìÈò¥ÂΩ±",
                    "‚ö° ÊïÖÈöúÊïàÊûú"
                ], {
                    "default": "Êó†ÊïàÊûú",
                    "tooltip": "ÈÄâÊã©È´òÁ∫ßËßÜËßâÁâπÊïàÔºàÂ∞ÜË¶ÜÁõñÂü∫Á°ÄËæπÊ°ÜÂíåÈò¥ÂΩ±ËÆæÁΩÆÔºâ"
                })
            }
        }
    
    RETURN_TYPES = ("IMAGE", "STRING")
    RETURN_NAMES = ("images", "processing_log")
    FUNCTION = "process_text_overlay"
    CATEGORY = "Video/Text"
    OUTPUT_NODE = False
    
    def process_text_overlay(self, images, ÊñáÊú¨ÂÜÖÂÆπ: str, TikTokÈ¢ÑËÆæ: str, ÊñáÊú¨‰ΩçÁΩÆ: str, 
                           Â≠ó‰ΩìÁ±ªÂûã: str, Â≠ó‰ΩìÂ§ßÂ∞è: int, Â≠ó‰ΩìÈ¢úËâ≤: str, ËÉåÊôØÈ¢úËâ≤: str,
                           ËÉåÊôØÈÄèÊòéÂ∫¶: float, ÊØèË°åÂ≠óÁ¨¶Êï∞: int, ËßÜËßâÊïàÊûú: str, **kwargs) -> Tuple[Any, str]:
        """
        Â§ÑÁêÜÊñáÊú¨Ë¶ÜÁõñ
        
        Args:
            images: ËæìÂÖ•ÂõæÂÉèÂ∫èÂàó
            ÊñáÊú¨ÂÜÖÂÆπ: ÊñáÊú¨ÂÜÖÂÆπ
            ÊñáÊú¨‰ΩçÁΩÆ: ‰ΩçÁΩÆ
            Â≠ó‰ΩìÁ±ªÂûã: Â≠ó‰ΩìÁ±ªÂûã
            Â≠ó‰ΩìÂ§ßÂ∞è: Â≠ó‰ΩìÂ§ßÂ∞è
            Â≠ó‰ΩìÈ¢úËâ≤: Â≠ó‰ΩìÈ¢úËâ≤È¢ÑËÆæ
            ËÉåÊôØÈ¢úËâ≤: ËÉåÊôØÈ¢úËâ≤È¢ÑËÆæ
            ËÉåÊôØÈÄèÊòéÂ∫¶: ËÉåÊôØÈÄèÊòéÂ∫¶
            ÊØèË°åÂ≠óÁ¨¶Êï∞: ÊØèË°åÊúÄÂ§ßÂ≠óÁ¨¶Êï∞
            **kwargs: ÂÖ∂‰ªñÂèØÈÄâÂèÇÊï∞
            
        Returns:
            (Â§ÑÁêÜÂêéÁöÑÂõæÂÉèÂ∫èÂàó, Â§ÑÁêÜÊó•Âøó)
        """
        # ÂàõÂª∫ËøõÂ∫¶ËÆ∞ÂΩïÂô®
        progress = ProgressLogger("ÊñáÊú¨Ë¶ÜÁõñÂ§ÑÁêÜ")
        
        # Âú®ÁªàÁ´ØÊòæÁ§∫ÂºÄÂßã‰ø°ÊÅØ
        print("\n" + "="*60)
        print("üé¨ ComfyUIÊñáÊú¨Ë¶ÜÁõñËßÜÈ¢ëËäÇÁÇπÂºÄÂßãÂ§ÑÁêÜ")
        print("="*60)
        
        try:
            # Ëé∑ÂèñÂèØÈÄâÂèÇÊï∞
            enable_background = kwargs.get("ÂêØÁî®ËÉåÊôØ", True)
            font_bold = kwargs.get("Á≤ó‰ΩìÂ≠ó", False)
            text_alignment_cn = kwargs.get("ÊñáÊú¨ÂØπÈΩê", "Â±Ö‰∏≠")
            enable_shadow = kwargs.get("ÂêØÁî®Èò¥ÂΩ±", False)
            enable_border = kwargs.get("ÂêØÁî®ËæπÊ°Ü", False)
            margin_x = kwargs.get("Ê∞¥Âπ≥ËæπË∑ù", 50)
            line_spacing = kwargs.get("Ë°åÈó¥Ë∑ù", 4)
            
            log_messages = []
            
            # Ê£ÄÊü•ÊòØÂê¶‰ΩøÁî®TikTokÈ¢ÑËÆæ
            if TikTokÈ¢ÑËÆæ != "‰∏ç‰ΩøÁî®È¢ÑËÆæ":
                # ‰ΩøÁî®TikTokÈ¢ÑËÆæÊ†∑Âºè
                progress.log_progress("Â∫îÁî®TikTokÈ¢ÑËÆæ", f"È¢ÑËÆæÊ†∑Âºè: {TikTokÈ¢ÑËÆæ}", 15.0)
                log_messages.append(f"üéØ ‰ΩøÁî®TikTokÈ¢ÑËÆæ: {TikTokÈ¢ÑËÆæ}")
                
                tiktok_style = self.get_tiktok_preset_style(TikTokÈ¢ÑËÆæ)
                if tiktok_style:
                    style = self.convert_subtitle_style_to_overlay_style(tiktok_style)
                    log_messages.append(f"‚úÖ ÊàêÂäüÂ∫îÁî®{TikTokÈ¢ÑËÆæ}Ê†∑ÂºèÈÖçÁΩÆ")
                    log_messages.append(f"üìù È¢ÑËÆæÂèÇÊï∞: Â≠ó‰ΩìÂ§ßÂ∞è{tiktok_style.font_size}px, ÊèèËæπ{tiktok_style.outline_width}px")
                else:
                    log_messages.append(f"‚ùå Êú™ÊâæÂà∞È¢ÑËÆæÊ†∑Âºè: {TikTokÈ¢ÑËÆæ}")
                    return images, "\n".join(log_messages)
            else:
                # ‰ΩøÁî®ÊâãÂä®ÈÖçÁΩÆÁöÑÊ†∑Âºè
                progress.log_progress("ÊâãÂä®ÈÖçÁΩÆÊ†∑Âºè", f"Â≠ó‰Ωì: {Â≠ó‰ΩìÁ±ªÂûã}, Â§ßÂ∞è: {Â≠ó‰ΩìÂ§ßÂ∞è}px", 15.0)
                log_messages.append(f"üîß ‰ΩøÁî®ÊâãÂä®ÈÖçÁΩÆÁöÑÊ†∑Âºè")
                
                # ËΩ¨Êç¢‰∏≠ÊñáÈÄâÈ°π‰∏∫ÂÜÖÈÉ®‰ΩøÁî®ÁöÑËã±ÊñáÂÄº
                position_en = self.get_position_preset(ÊñáÊú¨‰ΩçÁΩÆ)
                font_rgb = self.get_color_rgb(Â≠ó‰ΩìÈ¢úËâ≤)
                background_rgb = self.get_color_rgb(ËÉåÊôØÈ¢úËâ≤)
                text_alignment = self.get_text_alignment(text_alignment_cn)
                
                # ÂàõÂª∫Ê†∑ÂºèÈÖçÁΩÆ
                style = TextOverlayStyle()
                style.position_preset = position_en
                style.font_family = Â≠ó‰ΩìÁ±ªÂûã
                style.font_size = Â≠ó‰ΩìÂ§ßÂ∞è
                style.font_color = font_rgb
                style.background_color = background_rgb
                style.background_opacity = ËÉåÊôØÈÄèÊòéÂ∫¶ if ËÉåÊôØÈ¢úËâ≤ != "ÈÄèÊòé" else 0.0
                style.background_enabled = enable_background and ËÉåÊôØÈ¢úËâ≤ != "ÈÄèÊòé"
                style.font_bold = font_bold
                style.text_alignment = text_alignment
                style.enable_shadow = enable_shadow
                style.enable_border = enable_border
                style.margin_x = margin_x
                style.line_spacing = line_spacing
                
                log_messages.append(f"‰ΩçÁΩÆ: {ÊñáÊú¨‰ΩçÁΩÆ}, Â≠ó‰Ωì: {Â≠ó‰ΩìÁ±ªÂûã}, Â§ßÂ∞è: {Â≠ó‰ΩìÂ§ßÂ∞è}px")
                log_messages.append(f"Â≠ó‰ΩìÈ¢úËâ≤: {Â≠ó‰ΩìÈ¢úËâ≤} {font_rgb}")
                log_messages.append(f"ËÉåÊôØÈ¢úËâ≤: {ËÉåÊôØÈ¢úËâ≤} {background_rgb}")
                log_messages.append(f"ËÉåÊôØÈÄèÊòéÂ∫¶: {ËÉåÊôØÈÄèÊòéÂ∫¶}")
            
            # Â∫îÁî®ËßÜËßâÊïàÊûú
            if ËßÜËßâÊïàÊûú != "Êó†ÊïàÊûú":
                self.apply_visual_effect(style, ËßÜËßâÊïàÊûú)
                log_messages.append(f"üé® Â∫îÁî®ËßÜËßâÊïàÊûú: {ËßÜËßâÊïàÊûú}")
                progress.log_progress("Â∫îÁî®ËßÜËßâÊïàÊûú", f"ÁâπÊïà: {ËßÜËßâÊïàÊûú}", 22.0)
            
            # Â§ÑÁêÜÊñáÊú¨Êç¢Ë°å
            wrapped_text = self.wrap_text(ÊñáÊú¨ÂÜÖÂÆπ, ÊØèË°åÂ≠óÁ¨¶Êï∞)
            text_stats = self.get_text_stats(wrapped_text)
            
            # Ê≠•È™§1: ÊòæÁ§∫ÈÖçÁΩÆ‰ø°ÊÅØ
            progress.log_progress("ÂàùÂßãÂåñÈÖçÁΩÆ", f"ÊñáÊú¨: '{ÊñáÊú¨ÂÜÖÂÆπ[:20]}{'...' if len(ÊñáÊú¨ÂÜÖÂÆπ) > 20 else ''}'", 20.0)
            log_messages.append(f"ÂºÄÂßãÂ§ÑÁêÜÊñáÊú¨Ë¶ÜÁõñ: '{ÊñáÊú¨ÂÜÖÂÆπ}'")
            log_messages.append(f"Êç¢Ë°åÂêéÊñáÊú¨: {text_stats['total_lines']}Ë°å, ÊúÄÈïø{text_stats['max_line_length']}Â≠óÁ¨¶")
            log_messages.append(f"‰ΩçÁΩÆËÆ°ÁÆó: ÊåâËßÜÈ¢ëÈ´òÂ∫¶ÊØî‰æãËá™ÈÄÇÂ∫î")
            
            # ÊòæÁ§∫‰ΩçÁΩÆËÆ°ÁÆóËØ¶ÊÉÖÔºàÁî®‰∫éË∞ÉËØïÔºâ
            x_expr, y_expr = style.get_position_expression(1920, 1080)  # ‰ΩøÁî®Ê†áÂáÜÂàÜËæ®ÁéáËÆ°ÁÆóÁ§∫‰æã
            log_messages.append(f"‰ΩçÁΩÆË°®ËææÂºè: x={x_expr}, y={y_expr}")
            
            # Ê≠•È™§2: È™åËØÅÊ†∑ÂºèÈÖçÁΩÆ
            progress.log_progress("È™åËØÅÊ†∑ÂºèÈÖçÁΩÆ", f"È™åËØÅÊ†∑ÂºèÊúâÊïàÊÄß", 25.0)
            print(f"üîç ÂºÄÂßãÈ™åËØÅÊ†∑ÂºèÈÖçÁΩÆ...")
            is_valid, error_msg = self.service.validate_style(style)
            if not is_valid:
                error_message = f"‚ùå Ê†∑ÂºèÈÖçÁΩÆÈîôËØØ: {error_msg}"
                print(f"‚ùå Ê†∑ÂºèÈ™åËØÅÂ§±Ë¥•: {error_msg}")
                progress.log_error(error_message)
                log_messages.append(error_message)
                return images, "\n".join(log_messages)
            print(f"‚úÖ Ê†∑ÂºèÈÖçÁΩÆÈ™åËØÅÈÄöËøá")
            
            # Ê≠•È™§3: ÂáÜÂ§á‰∏¥Êó∂Êñá‰ª∂
            progress.log_progress("ÂáÜÂ§á‰∏¥Êó∂Êñá‰ª∂", "ÂàõÂª∫ËæìÂÖ•ËæìÂá∫Êñá‰ª∂", 35.0)
            
            # Áî±‰∫éComfyUI‰∏≠ÂõæÂÉèÂ§ÑÁêÜÈÄöÂ∏∏Âú®ÂÜÖÂ≠ò‰∏≠ËøõË°åÔºå
            # ËøôÈáåÊàë‰ª¨ÈúÄË¶ÅÂ∞ÜÂõæÂÉèÂ∫èÂàóËΩ¨Êç¢‰∏∫‰∏¥Êó∂ËßÜÈ¢ëÊñá‰ª∂ËøõË°åÂ§ÑÁêÜ
            log_messages.append("Ê≠£Âú®ËΩ¨Êç¢ÂõæÂÉèÂ∫èÂàó‰∏∫‰∏¥Êó∂ËßÜÈ¢ë...")
            
            # ÂàõÂª∫‰∏¥Êó∂Êñá‰ª∂
            with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as temp_input:
                temp_input_path = temp_input.name
            
            with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as temp_output:
                temp_output_path = temp_output.name
            
            try:
                # Ê≠•È™§4: ËΩ¨Êç¢ÂõæÂÉèÂ∫èÂàó‰∏∫ËßÜÈ¢ë
                print(f"üé¨ ÂºÄÂßãËΩ¨Êç¢ÂõæÂÉèÂ∫èÂàó‰∏∫ËßÜÈ¢ë...")
                print(f"üìä ËæìÂÖ•ÂõæÂÉèÊï∞Èáè: {len(images)}")
                print(f"üìÅ ‰∏¥Êó∂Êñá‰ª∂Ë∑ØÂæÑ: {temp_input_path}")
                progress.log_progress("ËΩ¨Êç¢ÂõæÂÉèÂ∫èÂàó", f"‰∏¥Êó∂Êñá‰ª∂: {os.path.basename(temp_input_path)}", 45.0)
                success = self._images_to_video(images, temp_input_path)
                if not success:
                    error_message = "‚ùå ÂõæÂÉèÂ∫èÂàóËΩ¨Êç¢‰∏∫ËßÜÈ¢ëÂ§±Ë¥•"
                    print(f"‚ùå ÂõæÂÉèÂ∫èÂàóËΩ¨Êç¢Â§±Ë¥•")
                    progress.log_error(error_message)
                    log_messages.append(error_message)
                    return images, "\n".join(log_messages)
                print(f"‚úÖ ÂõæÂÉèÂ∫èÂàóËΩ¨Êç¢ÊàêÂäü")
                
                progress.log_progress("ÂõæÂÉèÂ∫èÂàóËΩ¨Êç¢ÂÆåÊàê", "ÂáÜÂ§áÊ∑ªÂä†ÊñáÊú¨Ë¶ÜÁõñ", 65.0)
                log_messages.append("‚úÖ ÂõæÂÉèÂ∫èÂàóËΩ¨Êç¢ÂÆåÊàê")
                
                # Ê≠•È™§5: Ê∑ªÂä†ÊñáÊú¨Ë¶ÜÁõñ
                progress.log_progress("Ê∑ªÂä†ÊñáÊú¨Ë¶ÜÁõñ", f"‰ΩøÁî®FFmpegÂ§ÑÁêÜ", 75.0)
                log_messages.append("Ê≠£Âú®Ê∑ªÂä†ÊñáÊú¨Ë¶ÜÁõñ...")
                success = self.service.add_text_overlay(
                    temp_input_path, wrapped_text, temp_output_path, style
                )
                
                if not success:
                    error_message = "‚ùå ÊñáÊú¨Ë¶ÜÁõñÊ∑ªÂä†Â§±Ë¥•"
                    progress.log_error(error_message)
                    log_messages.append(error_message)
                    return images, "\n".join(log_messages)
                
                progress.log_progress("ÊñáÊú¨Ë¶ÜÁõñÂÆåÊàê", "ÂºÄÂßãËΩ¨Êç¢ÂõûÂõæÂÉèÂ∫èÂàó", 90.0)
                log_messages.append("‚úÖ ÊñáÊú¨Ë¶ÜÁõñÊ∑ªÂä†ÂÆåÊàê")
                
                # Ê≠•È™§6: Â∞ÜÂ§ÑÁêÜÂêéÁöÑËßÜÈ¢ëËΩ¨Êç¢ÂõûÂõæÂÉèÂ∫èÂàó
                progress.log_progress("ËΩ¨Êç¢ÂõûÂõæÂÉèÂ∫èÂàó", f"ËæìÂá∫Êñá‰ª∂: {os.path.basename(temp_output_path)}", 95.0)
                log_messages.append("Ê≠£Âú®ËΩ¨Êç¢ÂõûÂõæÂÉèÂ∫èÂàó...")
                processed_images = self._video_to_images(temp_output_path)
                
                if processed_images is None:
                    error_message = "‚ùå ËßÜÈ¢ëËΩ¨Êç¢‰∏∫ÂõæÂÉèÂ∫èÂàóÂ§±Ë¥•"
                    progress.log_error(error_message)
                    log_messages.append(error_message)
                    return images, "\n".join(log_messages)
                
                # Ê≠•È™§7: ÂÆåÊàêÂ§ÑÁêÜ
                progress.log_success("ÊñáÊú¨Ë¶ÜÁõñÂ§ÑÁêÜÂÆåÊàêÔºÅ")
                log_messages.append("‚úÖ Â§ÑÁêÜÂÆåÊàêÔºÅ")
                print("="*60)
                return processed_images, "\n".join(log_messages)
                
            finally:
                # Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
                try:
                    os.unlink(temp_input_path)
                    os.unlink(temp_output_path)
                except:
                    pass
                
        except Exception as e:
            import traceback
            error_msg = f"‚ùå Â§ÑÁêÜËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ: {str(e)}"
            traceback_str = traceback.format_exc()
            print(f"ÈîôËØØËØ¶ÊÉÖ:\n{traceback_str}")
            log_messages.append(error_msg)
            log_messages.append(f"ÈîôËØØËØ¶ÊÉÖ: {traceback_str}")
            return images, "\n".join(log_messages)
    
    def _images_to_video(self, images, output_path: str) -> bool:
        """
        Â∞ÜÂõæÂÉèÂ∫èÂàóËΩ¨Êç¢‰∏∫ËßÜÈ¢ëÊñá‰ª∂
        
        Args:
            images: ÂõæÂÉèÂ∫èÂàó
            output_path: ËæìÂá∫ËßÜÈ¢ëË∑ØÂæÑ
            
        Returns:
            ËΩ¨Êç¢ÊòØÂê¶ÊàêÂäü
        """
        try:
            import torch
            import numpy as np
            from PIL import Image
            import subprocess
            import tempfile
            import os
            
            # ÂàõÂª∫‰∏¥Êó∂ÁõÆÂΩï‰øùÂ≠òÂõæÂÉè
            temp_dir = tempfile.mkdtemp()
            
            try:
                # Â∞ÜÂº†ÈáèËΩ¨Êç¢‰∏∫PILÂõæÂÉèÂπ∂‰øùÂ≠ò
                if isinstance(images, torch.Tensor):
                    # Á°Æ‰øùÂº†ÈáèÂú®CPU‰∏ä
                    images = images.cpu()
                    
                    # ËΩ¨Êç¢Âº†ÈáèÊ†ºÂºè [batch, height, width, channels] -> [batch, channels, height, width]
                    if images.dim() == 4 and images.shape[-1] in [1, 3, 4]:
                        images = images.permute(0, 3, 1, 2)
                    
                    for i, img_tensor in enumerate(images):
                        # ËΩ¨Êç¢‰∏∫numpyÊï∞ÁªÑ
                        img_np = img_tensor.permute(1, 2, 0).numpy()
                        
                        # Á°Æ‰øùÂÄºÂú®0-255ËåÉÂõ¥ÂÜÖ
                        if img_np.max() <= 1.0:
                            img_np = (img_np * 255).astype(np.uint8)
                        else:
                            img_np = np.clip(img_np, 0, 255).astype(np.uint8)
                        
                        # ËΩ¨Êç¢‰∏∫PILÂõæÂÉè
                        if img_np.shape[2] == 1:
                            pil_img = Image.fromarray(img_np.squeeze(), mode='L')
                        elif img_np.shape[2] == 3:
                            pil_img = Image.fromarray(img_np, mode='RGB')
                        else:
                            pil_img = Image.fromarray(img_np[:,:,:3], mode='RGB')
                        
                        # ‰øùÂ≠òÂõæÂÉè
                        pil_img.save(os.path.join(temp_dir, f"frame_{i:06d}.png"))
                
                # ‰ΩøÁî®FFmpegÂ∞ÜÂõæÂÉèÂ∫èÂàóËΩ¨Êç¢‰∏∫ËßÜÈ¢ë
                cmd = [
                    'ffmpeg', '-y',
                    '-framerate', '30',  # ÈªòËÆ§Â∏ßÁéá
                    '-i', os.path.join(temp_dir, 'frame_%06d.png'),
                    '-c:v', 'libx264',
                    '-pix_fmt', 'yuv420p',
                    output_path
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True)
                
                if result.returncode == 0:
                    return True
                else:
                    logging.error(f"FFmpegËΩ¨Êç¢Â§±Ë¥•: {result.stderr}")
                    return False
                    
            finally:
                # Ê∏ÖÁêÜ‰∏¥Êó∂ÁõÆÂΩï
                import shutil
                shutil.rmtree(temp_dir, ignore_errors=True)
                
        except Exception as e:
            logging.error(f"ÂõæÂÉèÂ∫èÂàóËΩ¨Êç¢‰∏∫ËßÜÈ¢ëÊó∂ÂèëÁîüÈîôËØØ: {e}")
            return False
    
    def _video_to_images(self, video_path: str):
        """
        Â∞ÜËßÜÈ¢ëÊñá‰ª∂ËΩ¨Êç¢‰∏∫ÂõæÂÉèÂ∫èÂàó
        
        Args:
            video_path: ËßÜÈ¢ëÊñá‰ª∂Ë∑ØÂæÑ
            
        Returns:
            ÂõæÂÉèÂº†ÈáèÊàñNone
        """
        try:
            import torch
            import numpy as np
            from PIL import Image
            import subprocess
            import tempfile
            import os
            import re
            
            # ÂàõÂª∫‰∏¥Êó∂ÁõÆÂΩï
            temp_dir = tempfile.mkdtemp()
            
            try:
                # ‰ΩøÁî®FFmpegÊèêÂèñÂ∏ß
                cmd = [
                    'ffmpeg', '-y',
                    '-i', video_path,
                    '-f', 'image2',
                    os.path.join(temp_dir, 'frame_%06d.png')
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True)
                
                if result.returncode != 0:
                    logging.error(f"FFmpegÊèêÂèñÂ∏ßÂ§±Ë¥•: {result.stderr}")
                    return None
                
                # ËØªÂèñÊèêÂèñÁöÑÂõæÂÉè
                frame_files = sorted([f for f in os.listdir(temp_dir) if f.endswith('.png')])
                
                if not frame_files:
                    logging.error("Êú™ÊâæÂà∞ÊèêÂèñÁöÑÂ∏ß")
                    return None
                
                images = []
                for frame_file in frame_files:
                    frame_path = os.path.join(temp_dir, frame_file)
                    pil_img = Image.open(frame_path).convert('RGB')
                    
                    # ËΩ¨Êç¢‰∏∫numpyÊï∞ÁªÑ
                    img_np = np.array(pil_img).astype(np.float32) / 255.0
                    
                    # ËΩ¨Êç¢‰∏∫Âº†Èáè
                    img_tensor = torch.from_numpy(img_np)
                    images.append(img_tensor)
                
                # Â†ÜÂè†‰∏∫ÊâπÊ¨°Âº†Èáè
                if images:
                    return torch.stack(images)
                else:
                    return None
                    
            finally:
                # Ê∏ÖÁêÜ‰∏¥Êó∂ÁõÆÂΩï
                import shutil
                shutil.rmtree(temp_dir, ignore_errors=True)
                
        except Exception as e:
            logging.error(f"ËßÜÈ¢ëËΩ¨Êç¢‰∏∫ÂõæÂÉèÂ∫èÂàóÊó∂ÂèëÁîüÈîôËØØ: {e}")
            return None


# ComfyUIËäÇÁÇπÊ≥®ÂÜå
NODE_CLASS_MAPPINGS = {
    "TextOverlayVideoNode": TextOverlayVideoNode
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "TextOverlayVideoNode": "üìù Text Overlay Video"
}

# Â¶ÇÊûúÁõ¥Êé•ËøêË°åÊ≠§Êñá‰ª∂ÔºåËøõË°åÊµãËØï
if __name__ == "__main__":
    # ÁÆÄÂçïÊµãËØï
    node = TextOverlayVideoNode()
    print("‚úÖ TextOverlayVideoNode ËäÇÁÇπÂàõÂª∫ÊàêÂäü")
    print("üìã ËäÇÁÇπËæìÂÖ•Á±ªÂûã:", node.INPUT_TYPES())
